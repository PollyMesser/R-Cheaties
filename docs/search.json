[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Willkommen zu meinem R Wiki",
    "section": "",
    "text": "Hier sammle ich mein R-Wissenâ€¦"
  },
  {
    "objectID": "index.html#Ã¼berblick",
    "href": "index.html#Ã¼berblick",
    "title": "Willkommen zu meinem R Wiki",
    "section": "",
    "text": "Hier sammle ich mein R-Wissenâ€¦"
  },
  {
    "objectID": "index.html#inhalte",
    "href": "index.html#inhalte",
    "title": "Willkommen zu meinem R Wiki",
    "section": "Inhalte",
    "text": "Inhalte\n\n Datenstrukturen in R\n Daten Transformieren\n Strings und Datum\n Wahrscheinlichkeit\n Statistik Allgemein\n Grafiken\n Lineare Regression und ANOVA\n NÃ¼tzliche Tricks\n Jenseits von Grundlagenstatistik\n Zeitreihenanalyse\n Einfaches Programmieren\n R Markdown und VerÃ¶ffentlichen"
  },
  {
    "objectID": "5_DataStructures/9.6_dfRemoveNAs.html",
    "href": "5_DataStructures/9.6_dfRemoveNAs.html",
    "title": "Fehlende Werte aus Data Frame entfernen",
    "section": "",
    "text": "Wir mÃ¶chten Zeilen lÃ¶schen, die NAs enthalten.\nWir nutzen den penguins Datensatz aus dem Paket palmerpenguins:\n\n\nlibrary(palmerpenguins)\ndata(\"penguins\")\npinguine &lt;- penguins |&gt;\n  head(7)\npinguine\n\n# A tibble: 7 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n7 Adelie  Torgersen           38.9          17.8               181        3625\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\nFunktion na.omit() lÃ¶scht alle Zeilen mit NAs:\n\n\nsaubere_pinguine &lt;- na.omit(pinguine)\nsaubere_pinguine\n\n# A tibble: 6 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           36.7          19.3               193        3450\n5 Adelie  Torgersen           39.3          20.6               190        3650\n6 Adelie  Torgersen           38.9          17.8               181        3625\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n Vorsicht!\nDas LÃ¶schen von ganzen Zeilen aufgrund von NAs kann zu einer Verzerrung der Daten fÃ¼hren und sollte deshalb nur in AusnahmefÃ¤llen angewendet werden!"
  },
  {
    "objectID": "5_DataStructures/9.6_dfRemoveNAs.html#anwendung",
    "href": "5_DataStructures/9.6_dfRemoveNAs.html#anwendung",
    "title": "Fehlende Werte aus Data Frame entfernen",
    "section": "",
    "text": "Wir mÃ¶chten Zeilen lÃ¶schen, die NAs enthalten.\nWir nutzen den penguins Datensatz aus dem Paket palmerpenguins:\n\n\nlibrary(palmerpenguins)\ndata(\"penguins\")\npinguine &lt;- penguins |&gt;\n  head(7)\npinguine\n\n# A tibble: 7 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n7 Adelie  Torgersen           38.9          17.8               181        3625\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\nFunktion na.omit() lÃ¶scht alle Zeilen mit NAs:\n\n\nsaubere_pinguine &lt;- na.omit(pinguine)\nsaubere_pinguine\n\n# A tibble: 6 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           36.7          19.3               193        3450\n5 Adelie  Torgersen           39.3          20.6               190        3650\n6 Adelie  Torgersen           38.9          17.8               181        3625\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\n Vorsicht!\nDas LÃ¶schen von ganzen Zeilen aufgrund von NAs kann zu einer Verzerrung der Daten fÃ¼hren und sollte deshalb nur in AusnahmefÃ¤llen angewendet werden!"
  },
  {
    "objectID": "5_DataStructures/9.4_dfColumnsPosition.html",
    "href": "5_DataStructures/9.4_dfColumnsPosition.html",
    "title": "Spalten - Position in Data Frame",
    "section": "",
    "text": "Nutze die select() Funktion aus dem dplyr Paket\nAlternativ: List expressions (base) nutzen\n\nWir laden die ersten 5 Zeilen des Pinguin-Datensatzes aus dem Paket palmerpenguins:\n\nlibrary(palmerpenguins)\ndata(\"penguins\")\npinguine &lt;- head(penguins, 5)\npinguine\n\n# A tibble: 5 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;"
  },
  {
    "objectID": "5_DataStructures/9.4_dfColumnsPosition.html#spalten-anhand-ihrer-position-im-data-frame-auswÃ¤hlen",
    "href": "5_DataStructures/9.4_dfColumnsPosition.html#spalten-anhand-ihrer-position-im-data-frame-auswÃ¤hlen",
    "title": "Spalten - Position in Data Frame",
    "section": "",
    "text": "Nutze die select() Funktion aus dem dplyr Paket\nAlternativ: List expressions (base) nutzen\n\nWir laden die ersten 5 Zeilen des Pinguin-Datensatzes aus dem Paket palmerpenguins:\n\nlibrary(palmerpenguins)\ndata(\"penguins\")\npinguine &lt;- head(penguins, 5)\npinguine\n\n# A tibble: 5 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;"
  },
  {
    "objectID": "5_DataStructures/9.4_dfColumnsPosition.html#dplyr",
    "href": "5_DataStructures/9.4_dfColumnsPosition.html#dplyr",
    "title": "Spalten - Position in Data Frame",
    "section": "dplyr",
    "text": "dplyr\n\nEine Spalte wÃ¤hlen\n\nDann mit select() die 2. Spalte auswÃ¤hlen:\n\n\nlibrary(dplyr)\npinguine |&gt;\n  select(2)\n\n# A tibble: 5 Ã— 1\n  island   \n  &lt;fct&gt;    \n1 Torgersen\n2 Torgersen\n3 Torgersen\n4 Torgersen\n5 Torgersen\n\n\n\n\nMehrere Spalten\n\npinguine |&gt;\n  select(1, 3, 4)\n\n# A tibble: 5 Ã— 3\n  species bill_length_mm bill_depth_mm\n  &lt;fct&gt;            &lt;dbl&gt;         &lt;dbl&gt;\n1 Adelie            39.1          18.7\n2 Adelie            39.5          17.4\n3 Adelie            40.3          18  \n4 Adelie            NA            NA  \n5 Adelie            36.7          19.3\n\n\n\n\nEine Spanne von Spalten auswÃ¤hlen\n\npinguine |&gt;\n  select(2:5)\n\n# A tibble: 5 Ã— 4\n  island    bill_length_mm bill_depth_mm flipper_length_mm\n  &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;\n1 Torgersen           39.1          18.7               181\n2 Torgersen           39.5          17.4               186\n3 Torgersen           40.3          18                 195\n4 Torgersen           NA            NA                  NA\n5 Torgersen           36.7          19.3               193"
  },
  {
    "objectID": "5_DataStructures/9.4_dfColumnsPosition.html#list-expression",
    "href": "5_DataStructures/9.4_dfColumnsPosition.html#list-expression",
    "title": "Spalten - Position in Data Frame",
    "section": "List expression",
    "text": "List expression\n\nEine Spalte\n\nDie Nutzung der doppelten Klammern fÃ¼hrt zur Ausgabe eines Vektors:\n\n\npinguine[[2]]\n\n[1] Torgersen Torgersen Torgersen Torgersen Torgersen\nLevels: Biscoe Dream Torgersen\n\n\n\n\nMehrere Spalten\n\nEinfache Klammern fÃ¼hren zur Ausgabe eines Tibbles und kÃ¶nnen fÃ¼r die Auswahl von einer oder mehreren Spalten genutzt werden:\n\n\npinguine[2]\n\n# A tibble: 5 Ã— 1\n  island   \n  &lt;fct&gt;    \n1 Torgersen\n2 Torgersen\n3 Torgersen\n4 Torgersen\n5 Torgersen\n\n\n\npinguine[c(2, 4)]\n\n# A tibble: 5 Ã— 2\n  island    bill_depth_mm\n  &lt;fct&gt;             &lt;dbl&gt;\n1 Torgersen          18.7\n2 Torgersen          17.4\n3 Torgersen          18  \n4 Torgersen          NA  \n5 Torgersen          19.3"
  },
  {
    "objectID": "5_DataStructures/9.4_dfColumnsPosition.html#matrix-style",
    "href": "5_DataStructures/9.4_dfColumnsPosition.html#matrix-style",
    "title": "Spalten - Position in Data Frame",
    "section": "Matrix-Style",
    "text": "Matrix-Style\n\nDie Auswahl von Spalten kann auch im Matrix-Style stattfinden:\n\n\npinguine[, 3]\n\n# A tibble: 5 Ã— 1\n  bill_length_mm\n           &lt;dbl&gt;\n1           39.1\n2           39.5\n3           40.3\n4           NA  \n5           36.7\n\n\n\nAuch hier ist eine Mehrfachauswahl mÃ¶glich:\n\n\npinguine[, c(1, 3)]\n\n# A tibble: 5 Ã— 2\n  species bill_length_mm\n  &lt;fct&gt;            &lt;dbl&gt;\n1 Adelie            39.1\n2 Adelie            39.5\n3 Adelie            40.3\n4 Adelie            NA  \n5 Adelie            36.7"
  },
  {
    "objectID": "5_DataStructures/9.2_dataFrameFromRows.html",
    "href": "5_DataStructures/9.2_dataFrameFromRows.html",
    "title": "Data Frame aus Reihendaten",
    "section": "",
    "text": "Daten sind in Reihen / FÃ¤llen organisiert und sollen als Data Frame zusammengefÃ¼hrt werden"
  },
  {
    "objectID": "5_DataStructures/9.2_dataFrameFromRows.html#anwendungsfall",
    "href": "5_DataStructures/9.2_dataFrameFromRows.html#anwendungsfall",
    "title": "Data Frame aus Reihendaten",
    "section": "",
    "text": "Daten sind in Reihen / FÃ¤llen organisiert und sollen als Data Frame zusammengefÃ¼hrt werden"
  },
  {
    "objectID": "5_DataStructures/9.2_dataFrameFromRows.html#lÃ¶sung",
    "href": "5_DataStructures/9.2_dataFrameFromRows.html#lÃ¶sung",
    "title": "Data Frame aus Reihendaten",
    "section": "LÃ¶sung",
    "text": "LÃ¶sung\n\nSpeichere jede Reihe in einen 1-Reihen Data Frame.\nNutze rbind() aus dem Paket dplyr, um die Reihen zusammenzufÃ¼hren.\n\n\nlibrary(dplyr)\n\n\nAttache Paket: 'dplyr'\n\n\nDie folgenden Objekte sind maskiert von 'package:stats':\n\n    filter, lag\n\n\nDie folgenden Objekte sind maskiert von 'package:base':\n\n    intersect, setdiff, setequal, union\n\nr1 &lt;- data.frame(a = 1, b = 2, c = \"X\")\nr2 &lt;- data.frame(a = 3, b = 4, c = \"Y\")\nr3 &lt;- data.frame(a = 5, b = 6, c = \"Z\")\n\nrbind(r1, r2, r3)\n\n  a b c\n1 1 2 X\n2 3 4 Y\n3 5 6 Z\n\n\n\nReihen in einer Liste\n\nBei einer groÃŸen Anzahl von Reihen sind diese oft in Listen gespeichert.\nNutze bind_rows() aus dplyr.\n\n\nlist.of.rows &lt;- list(r1, r2, r3)\nbind_rows(list.of.rows)\n\n  a b c\n1 1 2 X\n2 3 4 Y\n3 5 6 Z\n\n\n\n\nJede Reihe in einer Liste\n\nl1 &lt;- list(a = 1, b = 2, c = \"X\")\nl2 &lt;- list(a = 3, b = 4, c = \"Y\")\nl3 &lt;- list(a = 5, b = 6, c = \"Z\")\nlist.of.lists &lt;- list(l1, l2, l3)\n\nbind_rows(list.of.lists)\n\n# A tibble: 3 Ã— 3\n      a     b c    \n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n1     1     2 X    \n2     3     4 Y    \n3     5     6 Z"
  },
  {
    "objectID": "5_DataStructures/2.5_listRemoveCondition.html",
    "href": "5_DataStructures/2.5_listRemoveCondition.html",
    "title": "Listenelemente nach Bedingung entfernen",
    "section": "",
    "text": "Es sollen Elemente, die eine bestimmte Bedingung erfÃ¼llen, aus einer Liste entfernt werden.\nZ. B. Werte, die undefiniert oder negativ sind oder unterhalb eines bestimmten Schwellenwertes liegen.\n\n\nlst &lt;- list(NA, 0, NA, 1, 2)"
  },
  {
    "objectID": "5_DataStructures/2.5_listRemoveCondition.html#anwendungsfall",
    "href": "5_DataStructures/2.5_listRemoveCondition.html#anwendungsfall",
    "title": "Listenelemente nach Bedingung entfernen",
    "section": "",
    "text": "Es sollen Elemente, die eine bestimmte Bedingung erfÃ¼llen, aus einer Liste entfernt werden.\nZ. B. Werte, die undefiniert oder negativ sind oder unterhalb eines bestimmten Schwellenwertes liegen.\n\n\nlst &lt;- list(NA, 0, NA, 1, 2)"
  },
  {
    "objectID": "5_DataStructures/2.5_listRemoveCondition.html#lÃ¶sung",
    "href": "5_DataStructures/2.5_listRemoveCondition.html#lÃ¶sung",
    "title": "Listenelemente nach Bedingung entfernen",
    "section": "LÃ¶sung:",
    "text": "LÃ¶sung:\n\nAnwenden der discard() Funktion aus dem purrr Paket.\nWerte, die dem Kriterium entsprechen, werden entfernt.\n\n\nlibrary(purrr)\n\nlst |&gt;\n  discard(is.na)\n\n[[1]]\n[1] 0\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] 2\n\n\n\nEntfernen von character strings:\n\nlst &lt;- list(3, \"dog\", 2, \"cat\", 1)\nlst |&gt;\n  discard(is.character)\n\n[[1]]\n[1] 3\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 1\n\n\n\n\nEine eigene Bedingung definieren:\n\nis_na_or_null &lt;- function(x) {\n  is.na(x) || is.null(x)\n}\n\nlst &lt;- list(1, NA, 2, NULL, 3)\nlst |&gt;\n  discard(is_na_or_null)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n\n\n\nKomplexe Objekte\n\nListen kÃ¶nnen komplexe Objekte enthalten, zum Beispiel lineare Modelle, die mit der lm() Funktion erstellt worden sind:\n\n\nmods &lt;- list(lm(x ~ y1),\n             lm(x ~ y2),\n             lm(x ~ y3))\n\n\nMit einer Bedingung kÃ¶nnen Modelle identifiziert werden, deren \\(R^2\\) kleiner a.s 0.7 sind, danach kÃ¶nnen diese Modelle mit der discard() Funktion entfernt werden:\n\n\nfilter_r2 &lt;- function(model) {\n  summary(model)$r.squared &lt; 0.7\n}\n\nmods |&gt;\n  discard(filter_r2)\n\n\nğŸ’« Die Gegenfunktion von discard() ist keep().\nğŸ’« In keep() werden Elemente angegeben, die in der Liste bleiben sollen."
  },
  {
    "objectID": "5_DataStructures/2.3_ListVector.html",
    "href": "5_DataStructures/2.3_ListVector.html",
    "title": "Liste in Vektor umwandeln",
    "section": "",
    "text": "Viele statistische Funktionen lassen sich auf Vektoren, aber nicht auf Listen anwenden.\n\n\n\n\niq.scores &lt;- list(100, 120, 103, 80, 99)\nmean(iq.scores)\n\n[1] NA"
  },
  {
    "objectID": "5_DataStructures/2.3_ListVector.html#anwendungsfall",
    "href": "5_DataStructures/2.3_ListVector.html#anwendungsfall",
    "title": "Liste in Vektor umwandeln",
    "section": "",
    "text": "Viele statistische Funktionen lassen sich auf Vektoren, aber nicht auf Listen anwenden.\n\n\n\n\niq.scores &lt;- list(100, 120, 103, 80, 99)\nmean(iq.scores)\n\n[1] NA"
  },
  {
    "objectID": "5_DataStructures/2.3_ListVector.html#lÃ¶sung",
    "href": "5_DataStructures/2.3_ListVector.html#lÃ¶sung",
    "title": "Liste in Vektor umwandeln",
    "section": "LÃ¶sung:",
    "text": "LÃ¶sung:\n\nunlist Funktion anwenden\n\n\nmean(unlist(iq.scores))\n\n[1] 100.4\n\n\n\nWeiteres Beispiel\n\ncat(iq.scores, \"\\n\")\n\nError in cat(iq.scores, \"\\n\"): Argument 1 (Typ 'list') wird nicht von 'cat' verstanden\n\n\n\ncat(\"IQ-Scores:\", unlist(iq.scores), \"\\n\")\n\nIQ-Scores: 100 120 103 80 99"
  },
  {
    "objectID": "5_DataStructures/2.1_nameWertListe.html",
    "href": "5_DataStructures/2.1_nameWertListe.html",
    "title": "Listen mit Name/Wert Assoziationen",
    "section": "",
    "text": "Es soll eine Liste erstellt werden, die Namen und Werte miteinander verbindet, Ã¤hnlich wie ein dictionary, hash oder lookup table in einer anderen Programmiersprache\n\nDie list() Funktion ermÃ¶glicht es, Elementen Namen zu geben:\n\nlst &lt;- list(mid = 0.5, right = 0.841, far.right = 0.977)\nlst\n\n$mid\n[1] 0.5\n\n$right\n[1] 0.841\n\n$far.right\n[1] 0.977"
  },
  {
    "objectID": "5_DataStructures/2.1_nameWertListe.html#anwendungsfall",
    "href": "5_DataStructures/2.1_nameWertListe.html#anwendungsfall",
    "title": "Listen mit Name/Wert Assoziationen",
    "section": "",
    "text": "Es soll eine Liste erstellt werden, die Namen und Werte miteinander verbindet, Ã¤hnlich wie ein dictionary, hash oder lookup table in einer anderen Programmiersprache\n\nDie list() Funktion ermÃ¶glicht es, Elementen Namen zu geben:\n\nlst &lt;- list(mid = 0.5, right = 0.841, far.right = 0.977)\nlst\n\n$mid\n[1] 0.5\n\n$right\n[1] 0.841\n\n$far.right\n[1] 0.977"
  },
  {
    "objectID": "5_DataStructures/2.1_nameWertListe.html#lÃ¶sung",
    "href": "5_DataStructures/2.1_nameWertListe.html#lÃ¶sung",
    "title": "Listen mit Name/Wert Assoziationen",
    "section": "LÃ¶sung:",
    "text": "LÃ¶sung:\nZwei Vektoren fÃ¼r Namen und Werte kann man zusammenfÃ¼hren, indem man zunÃ¤chst eine leere Liste erstellt und diese dann mit den Vektoren fÃ¼llt:\n\nvalues &lt;- c(1, 2, 3)\nnames &lt;- c(\"a\", \"b\", \"c\")\n\nlst &lt;- list()\nlst[names] &lt;- values\nlst\n\n$a\n[1] 1\n\n$b\n[1] 2\n\n$c\n[1] 3\n\n\n\nOder direkt\nMan kann die Werte auch direkt den Namen hinzufÃ¼gen, wenn man die Liste erstellt:\n\nlst &lt;- list(\n  far.left = -2,\n  left = -1,\n  mid = 0,\n  right = 1,\n  far.right = 2\n)\nlst\n\n$far.left\n[1] -2\n\n$left\n[1] -1\n\n$mid\n[1] 0\n\n$right\n[1] 1\n\n$far.right\n[1] 2\n\n\n\n\nOder so:\n\nvalues &lt;- -2:2\nnames &lt;- c(\"far.left\", \"left\", \"mid\", \"right\", \"far.right\")\nlst &lt;- list()\nlst[names] &lt;- values\nlst\n\n$far.left\n[1] -2\n\n$left\n[1] -1\n\n$mid\n[1] 0\n\n$right\n[1] 1\n\n$far.right\n[1] 2\n\n\n\n\nNutzung:\nWenn die Assoziation erstellt ist, kann die Liste ganz einfach Namen in Werte Ã¼bersetzen:\n\ncat(\"Die linke Grenze ist\", lst[[\"far.left\"]], \"\\n\")\n\nDie linke Grenze ist -2"
  },
  {
    "objectID": "5_DataStructures/1.1_vectorfactor.html",
    "href": "5_DataStructures/1.1_vectorfactor.html",
    "title": "Mehrere Vektoren zu Vektor und Faktor kombinieren",
    "section": "",
    "text": "Man hat mehrere Datengruppen, die jeweils aus einem Vektor bestehen.\nDie Vektoren sollen kombiniert werden, sodass ein langer Vektor entsteht und gleichzeitig eine Faktorvariable, die die Herkunft fÃ¼r jeden Wert markiert.\nz.B. wurden verschiedene Gruppen getrennt voneinander befragt und jetzt sollen Gruppenunterschiede berechnet werden."
  },
  {
    "objectID": "5_DataStructures/1.1_vectorfactor.html#anwendungsfall",
    "href": "5_DataStructures/1.1_vectorfactor.html#anwendungsfall",
    "title": "Mehrere Vektoren zu Vektor und Faktor kombinieren",
    "section": "",
    "text": "Man hat mehrere Datengruppen, die jeweils aus einem Vektor bestehen.\nDie Vektoren sollen kombiniert werden, sodass ein langer Vektor entsteht und gleichzeitig eine Faktorvariable, die die Herkunft fÃ¼r jeden Wert markiert.\nz.B. wurden verschiedene Gruppen getrennt voneinander befragt und jetzt sollen Gruppenunterschiede berechnet werden."
  },
  {
    "objectID": "5_DataStructures/1.1_vectorfactor.html#lÃ¶sung",
    "href": "5_DataStructures/1.1_vectorfactor.html#lÃ¶sung",
    "title": "Mehrere Vektoren zu Vektor und Faktor kombinieren",
    "section": "LÃ¶sung:",
    "text": "LÃ¶sung:\n\nEine Liste erstellen, die die Vektoren enthÃ¤lt\nMit der stack-Funktion kann die Liste in einen Data Frame mit 2 Spalten kombiniert werden:\n\n\nv1 &lt;- c(11:15)\nv2 &lt;- c(21:25)\nv3 &lt;- c(31:35)\n\ncomb &lt;- stack(list(v1 = v1, v2 = v2, v3 = v3)) # 3 Faktoren kombinieren\ncomb\n\n   values ind\n1      11  v1\n2      12  v1\n3      13  v1\n4      14  v1\n5      15  v1\n6      21  v2\n7      22  v2\n8      23  v2\n9      24  v2\n10     25  v2\n11     31  v3\n12     32  v3\n13     33  v3\n14     34  v3\n15     35  v3"
  },
  {
    "objectID": "5_DataStructures/1.1_vectorfactor.html#anova",
    "href": "5_DataStructures/1.1_vectorfactor.html#anova",
    "title": "Mehrere Vektoren zu Vektor und Faktor kombinieren",
    "section": "ANOVA",
    "text": "ANOVA\n\nJetzt kÃ¶nnen Gruppenunterschiede mittels einer ANOVA untersucht werden:\n\n\naov.comb &lt;- aov(values ~ ind, data = comb)\nsummary(aov.comb)\n\n            Df Sum Sq Mean Sq F value   Pr(&gt;F)    \nind          2   1000   500.0     200 6.11e-10 ***\nResiduals   12     30     2.5                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html",
    "href": "5_DataStructures/1_DataStructures.html",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Vektoren sind die grundlegendste Datenstruktur in R. Sie enthalten eine Sequenz von Elementen des gleichen Datentyps.\nVerwendung:\n\n# Numerische Vektoren\nzahlen &lt;- c(1, 2, 3, 4, 5)\ndecimal &lt;- c(1.5, 2.7, 3.14)\n\n# Character Vektoren\nnamen &lt;- c(\"Anna\", \"Bob\", \"Charlie\")\n\n# Logische Vektoren\nwahrheit &lt;- c(TRUE, FALSE, TRUE)\n\n# Zugriff auf Elemente\nzahlen[1]      # Erstes Element\n\n[1] 1\n\nzahlen[1:3]    # Erste drei Elemente\n\n[1] 1 2 3\n\n\nWeiterlesen: Vektoren zu Vektor und Faktor kombinieren\n\n\n\nDefinition: Listen kÃ¶nnen Elemente verschiedener Datentypen enthalten und sind rekursiv (kÃ¶nnen andere Listen enthalten).\nVerwendung:\n\n# Liste erstellen\nmeine_liste &lt;- list(\n  zahlen = c(1, 2, 3),\n  text = \"Hallo Welt\",\n  logik = TRUE,\n  matrix = matrix(1:6, nrow = 2)\n)\n\n# Zugriff auf Listenelemente\nmeine_liste$zahlen      # Mit $\n\n[1] 1 2 3\n\nmeine_liste[[1]]        # Mit Index\n\n[1] 1 2 3\n\nmeine_liste[[\"zahlen\"]] # Mit Namen\n\n[1] 1 2 3\n\n\nWeiterlesen:\n\nListen mit Name/Wert-Assoziationen\nElement aus Liste entfernen\nListe in Vektor umwandeln\nNull Elemente aus einer Liste entfernen\nListenelemente nach einer Bedingung entfernen\n\n\n\n\nDefinition: Mode beschreibt den grundlegenden Typ der Daten, die in einem Objekt gespeichert sind.\nVerwendung:\n\n# Verschiedene Modi\nmode(c(1, 2, 3))        # \"numeric\"\n\n[1] \"numeric\"\n\nmode(c(\"a\", \"b\"))       # \"character\"\n\n[1] \"character\"\n\nmode(c(TRUE, FALSE))    # \"logical\"\n\n[1] \"logical\"\n\nmode(list(1, 2, 3))     # \"list\"\n\n[1] \"list\"\n\n# Mode prÃ¼fen\nis.numeric(c(1, 2, 3))  # TRUE\n\n[1] TRUE\n\nis.character(\"text\")    # TRUE\n\n[1] TRUE\n\n\n\n\n\nDefinition: Class ist ein Attribut, das die objektorientierte Struktur eines Objekts definiert und bestimmt, wie Funktionen damit umgehen.\nVerwendung:\n\n# Class bestimmen\nx &lt;- c(1, 2, 3)\nclass(x)                # \"numeric\"\n\n[1] \"numeric\"\n\n# Class setzen\nclass(x) &lt;- \"meine_klasse\"\nclass(x)                # \"meine_klasse\"\n\n[1] \"meine_klasse\"\n\n# FÃ¼r verschiedene Objekte\nclass(data.frame())     # \"data.frame\"\n\n[1] \"data.frame\"\n\nclass(matrix(1:4, 2))   # \"matrix\" \"array\"\n\n[1] \"matrix\" \"array\" \n\n\n\n\n\nDefinition: Scalare sind einzelne Werte (technisch gesehen Vektoren der LÃ¤nge 1 in R).\nVerwendung:\n\n# Verschiedene Scalar-Typen\nzahl &lt;- 42\ntext &lt;- \"Einzelwort\"\nwahrheit &lt;- TRUE\n\n# PrÃ¼fung auf LÃ¤nge\nlength(zahl)    # 1\n\n[1] 1\n\nis.vector(zahl) # TRUE\n\n[1] TRUE\n\n\n\n\n\nDefinition: Matrices sind zweidimensionale Arrays mit Elementen des gleichen Datentyps, organisiert in Zeilen und Spalten.\nVerwendung:\n\n# Matrix erstellen\nmat1 &lt;- matrix(1:12, nrow = 3, ncol = 4)\nmat2 &lt;- matrix(1:12, nrow = 3, byrow = TRUE)\n\n# Mit Zeilen- und Spaltennamen\ndimnames(mat1) &lt;- list(\n  c(\"Zeile1\", \"Zeile2\", \"Zeile3\"),\n  c(\"Sp1\", \"Sp2\", \"Sp3\", \"Sp4\")\n)\n\n# Zugriff auf Elemente\nmat1[1, 2]          # Element in Zeile 1, Spalte 2\n\n[1] 4\n\nmat1[1, ]           # Erste Zeile\n\nSp1 Sp2 Sp3 Sp4 \n  1   4   7  10 \n\nmat1[, 2]           # Zweite Spalte\n\nZeile1 Zeile2 Zeile3 \n     4      5      6 \n\n\n\n\n\nDefinition: Arrays sind mehrdimensionale Verallgemeinerungen von Matrices mit mehr als zwei Dimensionen.\nVerwendung:\n\n# 3-dimensionales Array\narr &lt;- array(1:24, dim = c(3, 4, 2))\n\n# Mit Dimensionsnamen\ndimnames(arr) &lt;- list(\n  Zeilen = c(\"Z1\", \"Z2\", \"Z3\"),\n  Spalten = c(\"S1\", \"S2\", \"S3\", \"S4\"),\n  Schichten = c(\"Schicht1\", \"Schicht2\")\n)\n\n# Zugriff auf Elemente\narr[1, 2, 1]        # Spezifisches Element\n\n[1] 4\n\narr[, , 1]          # Erste Schicht\n\n      Spalten\nZeilen S1 S2 S3 S4\n    Z1  1  4  7 10\n    Z2  2  5  8 11\n    Z3  3  6  9 12\n\n\n\n\n\nDefinition: Factors reprÃ¤sentieren kategoriale Daten mit vordefinierten Levels (Kategorien).\nVerwendung:\n\n# Factor erstellen\ngeschlecht &lt;- factor(c(\"m\", \"w\", \"w\", \"m\", \"m\"))\nlevels(geschlecht)  # Zeigt Kategorien\n\n[1] \"m\" \"w\"\n\n# Mit benutzerdefinierten Levels\nnoten &lt;- factor(\n  c(\"gut\", \"schlecht\", \"mittel\", \"gut\"),\n  levels = c(\"schlecht\", \"mittel\", \"gut\"),\n  ordered = TRUE\n)\n\n# Factor-Eigenschaften\nis.factor(geschlecht)   # TRUE\n\n[1] TRUE\n\nnlevels(geschlecht)     # Anzahl der Levels\n\n[1] 2\n\ntable(geschlecht)       # HÃ¤ufigkeitstabelle\n\ngeschlecht\nm w \n3 2 \n\n\n\n\n\nDefinition: Data Frames sind zweidimensionale Strukturen, die Spalten verschiedener Datentypen enthalten kÃ¶nnen (wie Tabellen in Datenbanken).\nVerwendung:\n\n# Data Frame erstellen\ndf &lt;- data.frame(\n  Name = c(\"Anna\", \"Bob\", \"Charlie\"),\n  Alter = c(25, 30, 35),\n  Verheiratet = c(TRUE, FALSE, TRUE),\n  stringsAsFactors = FALSE\n)\n\n# Zugriff auf Daten\ndf$Name             # Spalte Ã¼ber Namen\n\n[1] \"Anna\"    \"Bob\"     \"Charlie\"\n\ndf[1, ]             # Erste Zeile\n\n  Name Alter Verheiratet\n1 Anna    25        TRUE\n\ndf[, \"Alter\"]       # Spalte Ã¼ber Namen\n\n[1] 25 30 35\n\ndf[df$Alter &gt; 28, ] # Bedingte Auswahl\n\n     Name Alter Verheiratet\n2     Bob    30       FALSE\n3 Charlie    35        TRUE\n\n# Informationen Ã¼ber Data Frame\nstr(df)             # Struktur anzeigen\n\n'data.frame':   3 obs. of  3 variables:\n $ Name       : chr  \"Anna\" \"Bob\" \"Charlie\"\n $ Alter      : num  25 30 35\n $ Verheiratet: logi  TRUE FALSE TRUE\n\nsummary(df)         # Zusammenfassung\n\n     Name               Alter      Verheiratet    \n Length:3           Min.   :25.0   Mode :logical  \n Class :character   1st Qu.:27.5   FALSE:1        \n Mode  :character   Median :30.0   TRUE :2        \n                    Mean   :30.0                  \n                    3rd Qu.:32.5                  \n                    Max.   :35.0                  \n\n\nWeiterlesen:\n\nData Frame aus Spaltendaten\nData Frame aus Reihendaten\nReihen an Data Frame anfÃ¼gen\nData Frame Spalten anhand ihrer Position auswÃ¤hlen\nData Frame Spalten nach Namen auswÃ¤hlen\nFehlende Werte (NA) aus Data Frame entfernen\nZwei Data Frames kombinieren\n\n\n\n\nDefinition: Tibbles sind eine moderne Variante der Data Frames aus dem tidyverse-Paket, mit verbessertem Verhalten und besserer Ausgabe.\nVerwendung:\n\n# Tibble erstellen (benÃ¶tigt tibble-Paket)\nlibrary(tibble)\n\ntbl &lt;- tibble(\n  Name = c(\"Anna\", \"Bob\", \"Charlie\"),\n  Alter = c(25, 30, 35),\n  Verheiratet = c(TRUE, FALSE, TRUE)\n)\n\n# Oder aus Data Frame konvertieren\ntbl2 &lt;- as_tibble(df)\n\n# Vorteile von Tibbles:\n# - Bessere Ausgabe (zeigt nur erste 10 Zeilen)\n# - Warnt bei problematischen Operationen\n# - BehÃ¤lt Datentypen besser bei\n# - UnterstÃ¼tzt unkonventionelle Spaltennamen\n\n# Zugriff funktioniert wie bei Data Frames\ntbl$Name\n\n[1] \"Anna\"    \"Bob\"     \"Charlie\"\n\ntbl[1, ]\n\n# A tibble: 1 Ã— 3\n  Name  Alter Verheiratet\n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;      \n1 Anna     25 TRUE       \n\n\n\n\n\n\nVektoren sind die Basis aller anderen Strukturen\nListen kÃ¶nnen verschiedene Datentypen kombinieren\nMatrices und Arrays sind fÃ¼r numerische Berechnungen optimiert\nFactors behandeln kategoriale Daten effizient\nData Frames sind ideal fÃ¼r gemischte Datentypen in Tabellenform\nTibbles bieten eine verbesserte Version der Data Frames\nMode und Class beschreiben die Eigenschaften aller Objekte\n\n\n\n\n\nVerwende Vektoren fÃ¼r homogene Datensequenzen\nVerwende Listen fÃ¼r heterogene Datensammlungen\nVerwende Matrices fÃ¼r numerische 2D-Berechnungen\nVerwende Arrays fÃ¼r mehrdimensionale numerische Daten\nVerwende Factors fÃ¼r kategoriale Variablen\nVerwende Data Frames fÃ¼r tabellarische Daten mit gemischten Typen\nVerwende Tibbles wenn du mit dem tidyverse arbeitest"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#vektoren-vectors",
    "href": "5_DataStructures/1_DataStructures.html#vektoren-vectors",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Vektoren sind die grundlegendste Datenstruktur in R. Sie enthalten eine Sequenz von Elementen des gleichen Datentyps.\nVerwendung:\n\n# Numerische Vektoren\nzahlen &lt;- c(1, 2, 3, 4, 5)\ndecimal &lt;- c(1.5, 2.7, 3.14)\n\n# Character Vektoren\nnamen &lt;- c(\"Anna\", \"Bob\", \"Charlie\")\n\n# Logische Vektoren\nwahrheit &lt;- c(TRUE, FALSE, TRUE)\n\n# Zugriff auf Elemente\nzahlen[1]      # Erstes Element\n\n[1] 1\n\nzahlen[1:3]    # Erste drei Elemente\n\n[1] 1 2 3\n\n\nWeiterlesen: Vektoren zu Vektor und Faktor kombinieren"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#listen-lists",
    "href": "5_DataStructures/1_DataStructures.html#listen-lists",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Listen kÃ¶nnen Elemente verschiedener Datentypen enthalten und sind rekursiv (kÃ¶nnen andere Listen enthalten).\nVerwendung:\n\n# Liste erstellen\nmeine_liste &lt;- list(\n  zahlen = c(1, 2, 3),\n  text = \"Hallo Welt\",\n  logik = TRUE,\n  matrix = matrix(1:6, nrow = 2)\n)\n\n# Zugriff auf Listenelemente\nmeine_liste$zahlen      # Mit $\n\n[1] 1 2 3\n\nmeine_liste[[1]]        # Mit Index\n\n[1] 1 2 3\n\nmeine_liste[[\"zahlen\"]] # Mit Namen\n\n[1] 1 2 3\n\n\nWeiterlesen:\n\nListen mit Name/Wert-Assoziationen\nElement aus Liste entfernen\nListe in Vektor umwandeln\nNull Elemente aus einer Liste entfernen\nListenelemente nach einer Bedingung entfernen"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#mode",
    "href": "5_DataStructures/1_DataStructures.html#mode",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Mode beschreibt den grundlegenden Typ der Daten, die in einem Objekt gespeichert sind.\nVerwendung:\n\n# Verschiedene Modi\nmode(c(1, 2, 3))        # \"numeric\"\n\n[1] \"numeric\"\n\nmode(c(\"a\", \"b\"))       # \"character\"\n\n[1] \"character\"\n\nmode(c(TRUE, FALSE))    # \"logical\"\n\n[1] \"logical\"\n\nmode(list(1, 2, 3))     # \"list\"\n\n[1] \"list\"\n\n# Mode prÃ¼fen\nis.numeric(c(1, 2, 3))  # TRUE\n\n[1] TRUE\n\nis.character(\"text\")    # TRUE\n\n[1] TRUE"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#class",
    "href": "5_DataStructures/1_DataStructures.html#class",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Class ist ein Attribut, das die objektorientierte Struktur eines Objekts definiert und bestimmt, wie Funktionen damit umgehen.\nVerwendung:\n\n# Class bestimmen\nx &lt;- c(1, 2, 3)\nclass(x)                # \"numeric\"\n\n[1] \"numeric\"\n\n# Class setzen\nclass(x) &lt;- \"meine_klasse\"\nclass(x)                # \"meine_klasse\"\n\n[1] \"meine_klasse\"\n\n# FÃ¼r verschiedene Objekte\nclass(data.frame())     # \"data.frame\"\n\n[1] \"data.frame\"\n\nclass(matrix(1:4, 2))   # \"matrix\" \"array\"\n\n[1] \"matrix\" \"array\""
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#scalare",
    "href": "5_DataStructures/1_DataStructures.html#scalare",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Scalare sind einzelne Werte (technisch gesehen Vektoren der LÃ¤nge 1 in R).\nVerwendung:\n\n# Verschiedene Scalar-Typen\nzahl &lt;- 42\ntext &lt;- \"Einzelwort\"\nwahrheit &lt;- TRUE\n\n# PrÃ¼fung auf LÃ¤nge\nlength(zahl)    # 1\n\n[1] 1\n\nis.vector(zahl) # TRUE\n\n[1] TRUE"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#matrices",
    "href": "5_DataStructures/1_DataStructures.html#matrices",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Matrices sind zweidimensionale Arrays mit Elementen des gleichen Datentyps, organisiert in Zeilen und Spalten.\nVerwendung:\n\n# Matrix erstellen\nmat1 &lt;- matrix(1:12, nrow = 3, ncol = 4)\nmat2 &lt;- matrix(1:12, nrow = 3, byrow = TRUE)\n\n# Mit Zeilen- und Spaltennamen\ndimnames(mat1) &lt;- list(\n  c(\"Zeile1\", \"Zeile2\", \"Zeile3\"),\n  c(\"Sp1\", \"Sp2\", \"Sp3\", \"Sp4\")\n)\n\n# Zugriff auf Elemente\nmat1[1, 2]          # Element in Zeile 1, Spalte 2\n\n[1] 4\n\nmat1[1, ]           # Erste Zeile\n\nSp1 Sp2 Sp3 Sp4 \n  1   4   7  10 \n\nmat1[, 2]           # Zweite Spalte\n\nZeile1 Zeile2 Zeile3 \n     4      5      6"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#arrays",
    "href": "5_DataStructures/1_DataStructures.html#arrays",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Arrays sind mehrdimensionale Verallgemeinerungen von Matrices mit mehr als zwei Dimensionen.\nVerwendung:\n\n# 3-dimensionales Array\narr &lt;- array(1:24, dim = c(3, 4, 2))\n\n# Mit Dimensionsnamen\ndimnames(arr) &lt;- list(\n  Zeilen = c(\"Z1\", \"Z2\", \"Z3\"),\n  Spalten = c(\"S1\", \"S2\", \"S3\", \"S4\"),\n  Schichten = c(\"Schicht1\", \"Schicht2\")\n)\n\n# Zugriff auf Elemente\narr[1, 2, 1]        # Spezifisches Element\n\n[1] 4\n\narr[, , 1]          # Erste Schicht\n\n      Spalten\nZeilen S1 S2 S3 S4\n    Z1  1  4  7 10\n    Z2  2  5  8 11\n    Z3  3  6  9 12"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#factors",
    "href": "5_DataStructures/1_DataStructures.html#factors",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Factors reprÃ¤sentieren kategoriale Daten mit vordefinierten Levels (Kategorien).\nVerwendung:\n\n# Factor erstellen\ngeschlecht &lt;- factor(c(\"m\", \"w\", \"w\", \"m\", \"m\"))\nlevels(geschlecht)  # Zeigt Kategorien\n\n[1] \"m\" \"w\"\n\n# Mit benutzerdefinierten Levels\nnoten &lt;- factor(\n  c(\"gut\", \"schlecht\", \"mittel\", \"gut\"),\n  levels = c(\"schlecht\", \"mittel\", \"gut\"),\n  ordered = TRUE\n)\n\n# Factor-Eigenschaften\nis.factor(geschlecht)   # TRUE\n\n[1] TRUE\n\nnlevels(geschlecht)     # Anzahl der Levels\n\n[1] 2\n\ntable(geschlecht)       # HÃ¤ufigkeitstabelle\n\ngeschlecht\nm w \n3 2"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#data-frames",
    "href": "5_DataStructures/1_DataStructures.html#data-frames",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Data Frames sind zweidimensionale Strukturen, die Spalten verschiedener Datentypen enthalten kÃ¶nnen (wie Tabellen in Datenbanken).\nVerwendung:\n\n# Data Frame erstellen\ndf &lt;- data.frame(\n  Name = c(\"Anna\", \"Bob\", \"Charlie\"),\n  Alter = c(25, 30, 35),\n  Verheiratet = c(TRUE, FALSE, TRUE),\n  stringsAsFactors = FALSE\n)\n\n# Zugriff auf Daten\ndf$Name             # Spalte Ã¼ber Namen\n\n[1] \"Anna\"    \"Bob\"     \"Charlie\"\n\ndf[1, ]             # Erste Zeile\n\n  Name Alter Verheiratet\n1 Anna    25        TRUE\n\ndf[, \"Alter\"]       # Spalte Ã¼ber Namen\n\n[1] 25 30 35\n\ndf[df$Alter &gt; 28, ] # Bedingte Auswahl\n\n     Name Alter Verheiratet\n2     Bob    30       FALSE\n3 Charlie    35        TRUE\n\n# Informationen Ã¼ber Data Frame\nstr(df)             # Struktur anzeigen\n\n'data.frame':   3 obs. of  3 variables:\n $ Name       : chr  \"Anna\" \"Bob\" \"Charlie\"\n $ Alter      : num  25 30 35\n $ Verheiratet: logi  TRUE FALSE TRUE\n\nsummary(df)         # Zusammenfassung\n\n     Name               Alter      Verheiratet    \n Length:3           Min.   :25.0   Mode :logical  \n Class :character   1st Qu.:27.5   FALSE:1        \n Mode  :character   Median :30.0   TRUE :2        \n                    Mean   :30.0                  \n                    3rd Qu.:32.5                  \n                    Max.   :35.0                  \n\n\nWeiterlesen:\n\nData Frame aus Spaltendaten\nData Frame aus Reihendaten\nReihen an Data Frame anfÃ¼gen\nData Frame Spalten anhand ihrer Position auswÃ¤hlen\nData Frame Spalten nach Namen auswÃ¤hlen\nFehlende Werte (NA) aus Data Frame entfernen\nZwei Data Frames kombinieren"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#tibbles",
    "href": "5_DataStructures/1_DataStructures.html#tibbles",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Definition: Tibbles sind eine moderne Variante der Data Frames aus dem tidyverse-Paket, mit verbessertem Verhalten und besserer Ausgabe.\nVerwendung:\n\n# Tibble erstellen (benÃ¶tigt tibble-Paket)\nlibrary(tibble)\n\ntbl &lt;- tibble(\n  Name = c(\"Anna\", \"Bob\", \"Charlie\"),\n  Alter = c(25, 30, 35),\n  Verheiratet = c(TRUE, FALSE, TRUE)\n)\n\n# Oder aus Data Frame konvertieren\ntbl2 &lt;- as_tibble(df)\n\n# Vorteile von Tibbles:\n# - Bessere Ausgabe (zeigt nur erste 10 Zeilen)\n# - Warnt bei problematischen Operationen\n# - BehÃ¤lt Datentypen besser bei\n# - UnterstÃ¼tzt unkonventionelle Spaltennamen\n\n# Zugriff funktioniert wie bei Data Frames\ntbl$Name\n\n[1] \"Anna\"    \"Bob\"     \"Charlie\"\n\ntbl[1, ]\n\n# A tibble: 1 Ã— 3\n  Name  Alter Verheiratet\n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;      \n1 Anna     25 TRUE"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#zusammenfassung-der-beziehungen",
    "href": "5_DataStructures/1_DataStructures.html#zusammenfassung-der-beziehungen",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Vektoren sind die Basis aller anderen Strukturen\nListen kÃ¶nnen verschiedene Datentypen kombinieren\nMatrices und Arrays sind fÃ¼r numerische Berechnungen optimiert\nFactors behandeln kategoriale Daten effizient\nData Frames sind ideal fÃ¼r gemischte Datentypen in Tabellenform\nTibbles bieten eine verbesserte Version der Data Frames\nMode und Class beschreiben die Eigenschaften aller Objekte"
  },
  {
    "objectID": "5_DataStructures/1_DataStructures.html#wahl-der-richtigen-datenstruktur",
    "href": "5_DataStructures/1_DataStructures.html#wahl-der-richtigen-datenstruktur",
    "title": "1 Datenstrukturen",
    "section": "",
    "text": "Verwende Vektoren fÃ¼r homogene Datensequenzen\nVerwende Listen fÃ¼r heterogene Datensammlungen\nVerwende Matrices fÃ¼r numerische 2D-Berechnungen\nVerwende Arrays fÃ¼r mehrdimensionale numerische Daten\nVerwende Factors fÃ¼r kategoriale Variablen\nVerwende Data Frames fÃ¼r tabellarische Daten mit gemischten Typen\nVerwende Tibbles wenn du mit dem tidyverse arbeitest"
  },
  {
    "objectID": "5_DataStructures/2.2_ElementListeEntfernen.html",
    "href": "5_DataStructures/2.2_ElementListeEntfernen.html",
    "title": "Element aus einer Liste entfernen",
    "section": "",
    "text": "Ein Element soll von einer Liste entfernt werden"
  },
  {
    "objectID": "5_DataStructures/2.2_ElementListeEntfernen.html#anwendungsfall",
    "href": "5_DataStructures/2.2_ElementListeEntfernen.html#anwendungsfall",
    "title": "Element aus einer Liste entfernen",
    "section": "",
    "text": "Ein Element soll von einer Liste entfernt werden"
  },
  {
    "objectID": "5_DataStructures/2.2_ElementListeEntfernen.html#lÃ¶sung",
    "href": "5_DataStructures/2.2_ElementListeEntfernen.html#lÃ¶sung",
    "title": "Element aus einer Liste entfernen",
    "section": "LÃ¶sung:",
    "text": "LÃ¶sung:\n\nWeise dem Element NULL zu.\n\n\nyears &lt;- list(\n  kennedy = 1960,\n  Johnson = 1964,\n  Carter = 1976,\n  Clinton = 1994)\n\nyears\n\n$kennedy\n[1] 1960\n\n$Johnson\n[1] 1964\n\n$Carter\n[1] 1976\n\n$Clinton\n[1] 1994\n\n\n\nEinzelnes Element entfernen:\n\nyears[[\"Johnson\"]] &lt;- NULL # Element entfernen\nyears\n\n$kennedy\n[1] 1960\n\n$Carter\n[1] 1976\n\n$Clinton\n[1] 1994\n\n\n\n\nMehrere Elemente:\n\nyears[c(\"Carter\", \"Clinton\")] &lt;- NULL\nyears\n\n$kennedy\n[1] 1960"
  },
  {
    "objectID": "5_DataStructures/2.4_removeNullList.html",
    "href": "5_DataStructures/2.4_removeNullList.html",
    "title": "Null Elemente aus Liste entfernen",
    "section": "",
    "text": "Liste enthÃ¤lt NULL-Werte, die entfernt werden sollen\n\n\nlst &lt;- list(\"Moe\", NULL, \"Curly\")\nlst\n\n[[1]]\n[1] \"Moe\"\n\n[[2]]\nNULL\n\n[[3]]\n[1] \"Curly\""
  },
  {
    "objectID": "5_DataStructures/2.4_removeNullList.html#anwendungsfall",
    "href": "5_DataStructures/2.4_removeNullList.html#anwendungsfall",
    "title": "Null Elemente aus Liste entfernen",
    "section": "",
    "text": "Liste enthÃ¤lt NULL-Werte, die entfernt werden sollen\n\n\nlst &lt;- list(\"Moe\", NULL, \"Curly\")\nlst\n\n[[1]]\n[1] \"Moe\"\n\n[[2]]\nNULL\n\n[[3]]\n[1] \"Curly\""
  },
  {
    "objectID": "5_DataStructures/2.4_removeNullList.html#lÃ¶sung",
    "href": "5_DataStructures/2.4_removeNullList.html#lÃ¶sung",
    "title": "Null Elemente aus Liste entfernen",
    "section": "LÃ¶sung:",
    "text": "LÃ¶sung:\n\nAnwenden der compact() Funktion aus dem purrr Paket\n\n\nlibrary(purrr)\n\ncompact(lst)\n\n[[1]]\n[1] \"Moe\"\n\n[[2]]\n[1] \"Curly\"\n\n\n\nğŸ’« In R sind NA und NULL nicht dasselbe.\nğŸ’« compact() entfernt nur NULL Werte, nicht NAs."
  },
  {
    "objectID": "5_DataStructures/9.1_dataFrameFromColumns.html",
    "href": "5_DataStructures/9.1_dataFrameFromColumns.html",
    "title": "Data Frame aus Spaltendaten",
    "section": "",
    "text": "Daten sind in mehrere Vektoren und Faktoren angelegt und sollen in einen Data Frame zusammengefÃ¼hrt werden.\nDaten sind als Vektoren und Faktoren in einer Liste gespeichert und sollen in Data Frame Ã¼berfÃ¼hrt werden."
  },
  {
    "objectID": "5_DataStructures/9.1_dataFrameFromColumns.html#anwendungsfall",
    "href": "5_DataStructures/9.1_dataFrameFromColumns.html#anwendungsfall",
    "title": "Data Frame aus Spaltendaten",
    "section": "",
    "text": "Daten sind in mehrere Vektoren und Faktoren angelegt und sollen in einen Data Frame zusammengefÃ¼hrt werden.\nDaten sind als Vektoren und Faktoren in einer Liste gespeichert und sollen in Data Frame Ã¼berfÃ¼hrt werden."
  },
  {
    "objectID": "5_DataStructures/9.1_dataFrameFromColumns.html#lÃ¶sung",
    "href": "5_DataStructures/9.1_dataFrameFromColumns.html#lÃ¶sung",
    "title": "Data Frame aus Spaltendaten",
    "section": "LÃ¶sung:",
    "text": "LÃ¶sung:\n\nv1 &lt;- 1:5\nv2 &lt;- -5:-1\nv3 &lt;- 6:10\nf1 &lt;- c(\"Hund\", \"Kuchen\", \"Fische\", \"Pupsi\", \"Kinder\")\ndf &lt;- data.frame(v1, v2, v3, f1)\ndf\n\n  v1 v2 v3     f1\n1  1 -5  6   Hund\n2  2 -4  7 Kuchen\n3  3 -3  8 Fische\n4  4 -2  9  Pupsi\n5  5 -1 10 Kinder\n\n\n\nlst &lt;- list(v1 = v1, v2 = v2, v3 = v3, f1 = f1) # Spaltennamen (name/value Paare)\ndf &lt;- as.data.frame(lst)\ndf\n\n  v1 v2 v3     f1\n1  1 -5  6   Hund\n2  2 -4  7 Kuchen\n3  3 -3  8 Fische\n4  4 -2  9  Pupsi\n5  5 -1 10 Kinder"
  },
  {
    "objectID": "5_DataStructures/9.1_dataFrameFromColumns.html#tibble",
    "href": "5_DataStructures/9.1_dataFrameFromColumns.html#tibble",
    "title": "Data Frame aus Spaltendaten",
    "section": "Tibble",
    "text": "Tibble\n\ntibble() Funktion aus dem tidiverse\n\n\nlibrary(tibble)\ntibble(v1 = v1, v2 = v2, v3 = v3, factor = f1)\n\n# A tibble: 5 Ã— 4\n     v1    v2    v3 factor\n  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; \n1     1    -5     6 Hund  \n2     2    -4     7 Kuchen\n3     3    -3     8 Fische\n4     4    -2     9 Pupsi \n5     5    -1    10 Kinder\n\n\n\nas_tibble() Funktion, wenn die Daten in einer Liste gespeichert sind:\n\n\nas_tibble(lst)\n\n# A tibble: 5 Ã— 4\n     v1    v2    v3 f1    \n  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; \n1     1    -5     6 Hund  \n2     2    -4     7 Kuchen\n3     3    -3     8 Fische\n4     4    -2     9 Pupsi \n5     5    -1    10 Kinder"
  },
  {
    "objectID": "5_DataStructures/9.3_rowsToDataFrame.html",
    "href": "5_DataStructures/9.3_rowsToDataFrame.html",
    "title": "Reihen an Data Frame anfÃ¼gen",
    "section": "",
    "text": "Es liegt eine oder mehrere Reihen Daten vor, die an einen Data Frame angeheftet werden sollen."
  },
  {
    "objectID": "5_DataStructures/9.3_rowsToDataFrame.html#anwendungsfall",
    "href": "5_DataStructures/9.3_rowsToDataFrame.html#anwendungsfall",
    "title": "Reihen an Data Frame anfÃ¼gen",
    "section": "",
    "text": "Es liegt eine oder mehrere Reihen Daten vor, die an einen Data Frame angeheftet werden sollen."
  },
  {
    "objectID": "5_DataStructures/9.3_rowsToDataFrame.html#lÃ¶sung",
    "href": "5_DataStructures/9.3_rowsToDataFrame.html#lÃ¶sung",
    "title": "Reihen an Data Frame anfÃ¼gen",
    "section": "LÃ¶sung:",
    "text": "LÃ¶sung:\n\nErstelle einen neuen, temporÃ¤ren Data Frame, der die neuen Reihen enthÃ¤lt.\nFÃ¼ge den Data Frame an den originalen Data Frame, indem du die Funktion rbind()` verwendest.\n\nAngenommen, wir haben einen Data Frame mit Pokemon-Daten:\n\nlibrary(readr)\npokemon &lt;- read.csv(\"pokemon.csv\", encoding = \"UTF-8\")\nhead(pokemon) # erste sechs Reihen ausgeben\n\n       Name          Typ Region Level Kraftpunkte ASCII_Sprite\n1   Pikachu      Elektro  Kanto    25         274    (âš¡áµ”á´¥áµ”âš¡)\n2 Charizard   Feuer/Flug  Kanto    36         360   ğŸ”¥(â•¯Â°â–¡Â°ï¼‰â•¯ğŸ”¥\n3 Blastoise       Wasser  Kanto    36         362    ğŸ’§á••( á› )á•—ğŸ’§\n4  Venusaur Pflanze/Gift  Kanto    32         364      ğŸŒ¸(â—•â€¿â—•)ğŸŒ¿\n5    Mewtwo       Psycho  Kanto    70         416    âœ¨(à² _à² )âœ¨\n6       Mew       Psycho  Kanto   100         404    âœ¨(â—•Ï‰â—•)âœ¨\n\n\nWir wollen eine neue Reihe anfÃ¼gen:\n\npokeNeu &lt;- data.frame(\n  Name = \"Zamazenta\",\n  Typ = \"Kampf/Stahl\",\n  Region = \"Galar\",\n  Level = 70,\n  Kraftpunkte = 362,\n  ASCII_Sprite = \"ğŸ›¡ï¸ğŸº(à² _à² )ğŸºğŸ›¡ï¸\"\n)\npokeNeu\n\n       Name         Typ Region Level Kraftpunkte ASCII_Sprite\n1 Zamazenta Kampf/Stahl  Galar    70         362    ğŸ›¡ï¸ğŸº(à² _à² )ğŸºğŸ›¡ï¸\n\n\nJetzt verwenden wir die rbind() Funktion, um den Data Frame an den existierenden dranzuhÃ¤ngen:\n\nrbind(pokemon, pokeNeu)\n\n        Name            Typ Region Level Kraftpunkte   ASCII_Sprite\n1    Pikachu        Elektro  Kanto    25         274      (âš¡áµ”á´¥áµ”âš¡)\n2  Charizard     Feuer/Flug  Kanto    36         360     ğŸ”¥(â•¯Â°â–¡Â°ï¼‰â•¯ğŸ”¥\n3  Blastoise         Wasser  Kanto    36         362      ğŸ’§á••( á› )á•—ğŸ’§\n4   Venusaur   Pflanze/Gift  Kanto    32         364        ğŸŒ¸(â—•â€¿â—•)ğŸŒ¿\n5     Mewtwo         Psycho  Kanto    70         416      âœ¨(à² _à² )âœ¨\n6        Mew         Psycho  Kanto   100         404      âœ¨(â—•Ï‰â—•)âœ¨\n7      Lugia    Psycho/Flug  Johto    45         461      ğŸŒŠ(ï¿£^ï¿£)ğŸŒŠ\n8      Ho-Oh     Feuer/Flug  Johto    45         461 ğŸ”¥ã€ˆ(ï¿£ï¸¶ï¿£)ã€‰ğŸ”¥\n9     Celebi Psycho/Pflanze  Johto   100         404        ğŸƒ(â— â€¿â— )ğŸƒ\n10  Rayquaza    Drache/Flug  Hoenn    50         461      ğŸ‰â•â•â•â•â•â•â•ğŸ‰\n11    Kyogre         Wasser  Hoenn    45         383    ğŸŒŠâ‰‹â‰‹(â—‰â—¡â—‰)â‰‹â‰‹ğŸŒŠ\n12   Groudon          Boden  Hoenn    45         383       â›°ï¸(à² ç›Šà² )â›°ï¸\n13    Dialga   Stahl/Drache Sinnoh    47         461      âš™ï¸ğŸ²(â—‰_â—‰)ğŸ²âš™ï¸\n14    Palkia  Wasser/Drache Sinnoh    47         461      ğŸ’ğŸ²(âŠ™_âŠ™)ğŸ²ğŸ’\n15  Giratina   Geist/Drache Sinnoh    47         461      ğŸ‘»ğŸ²(Â¬_Â¬)ğŸ²ğŸ‘»\n16    Arceus         Normal Sinnoh    80         493      â­(â—‰Î˜â—‰)â­\n17  Reshiram   Drache/Feuer Einall    50         461     ğŸ”¥ğŸ²(âŒâ– _â– )ğŸ²ğŸ”¥\n18    Zekrom Drache/Elektro Einall    50         461    âš¡ğŸ²(à² â€¿à² )ğŸ²âš¡\n19    Kyurem     Drache/Eis Einall    50         461     â„ï¸ğŸ²(â•¯ï¸µâ•°)ğŸ²â„ï¸\n20   Xerneas            Fee  Kalos    50         461    ğŸ¦Œâœ¨(â—•â€¿â—•)âœ¨ğŸ¦Œ\n21   Yveltal   Unlicht/Flug  Kalos    50         461      ğŸ¦…ğŸ’€(à² _à² )ğŸ’€ğŸ¦…\n22   Zygarde   Drache/Boden  Kalos    50         486    ğŸâ¬¢â¬¡(â—‰_â—‰)â¬¡â¬¢ğŸ\n23  Solgaleo   Psycho/Stahl  Alola    55         461      â˜€ï¸ğŸ¦(â—‰â—¡â—‰)ğŸ¦â˜€ï¸\n24    Lunala   Psycho/Geist  Alola    55         461      ğŸŒ™ğŸ¦‡(â—•â€¿â—•)ğŸ¦‡ğŸŒ™\n25  Necrozma         Psycho  Alola    50         461  ğŸ’âœ¨(â•¬à² ç›Šà² )âœ¨ğŸ’\n26    Zacian      Fee/Stahl  Galar    70         362      ğŸ—¡ï¸ğŸº(â—•â€¿â—•)ğŸºğŸ—¡ï¸\n27 Zamazenta    Kampf/Stahl  Galar    70         362      ğŸ›¡ï¸ğŸº(à² _à² )ğŸºğŸ›¡ï¸"
  },
  {
    "objectID": "5_DataStructures/9.5_dfColumnsNames.html",
    "href": "5_DataStructures/9.5_dfColumnsNames.html",
    "title": "Spalten - Namen in Data Frame",
    "section": "",
    "text": "Wir nutzen wieder die ersten 5 Zeilen aus dem Pinguin Datensatz:\n\n\nlibrary(palmerpenguins)\n\ndata(\"penguins\")\npinguine &lt;- penguins |&gt;\n  head(5)\npinguine\n\n# A tibble: 5 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;"
  },
  {
    "objectID": "5_DataStructures/9.5_dfColumnsNames.html#spalten-in-einem-data-frame-nach-ihren-namen-auswÃ¤hlen",
    "href": "5_DataStructures/9.5_dfColumnsNames.html#spalten-in-einem-data-frame-nach-ihren-namen-auswÃ¤hlen",
    "title": "Spalten - Namen in Data Frame",
    "section": "",
    "text": "Wir nutzen wieder die ersten 5 Zeilen aus dem Pinguin Datensatz:\n\n\nlibrary(palmerpenguins)\n\ndata(\"penguins\")\npinguine &lt;- penguins |&gt;\n  head(5)\npinguine\n\n# A tibble: 5 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;"
  },
  {
    "objectID": "5_DataStructures/9.5_dfColumnsNames.html#dplyr",
    "href": "5_DataStructures/9.5_dfColumnsNames.html#dplyr",
    "title": "Spalten - Namen in Data Frame",
    "section": "dplyr",
    "text": "dplyr\n\nNutze select() aus dem dplyr Paket mit den Spaltennamen:\n\n\nlibrary(dplyr)\n\npinguine |&gt;\n  select(species, island)\n\n# A tibble: 5 Ã— 2\n  species island   \n  &lt;fct&gt;   &lt;fct&gt;    \n1 Adelie  Torgersen\n2 Adelie  Torgersen\n3 Adelie  Torgersen\n4 Adelie  Torgersen\n5 Adelie  Torgersen"
  },
  {
    "objectID": "5_DataStructures/9.5_dfColumnsNames.html#list-expression",
    "href": "5_DataStructures/9.5_dfColumnsNames.html#list-expression",
    "title": "Spalten - Namen in Data Frame",
    "section": "List expression",
    "text": "List expression\n\nAuswahl mit dem Namen funktioniert auch mit List expressions.\n\n\nEinzelne Spalte\n\nNutze doppelte Klammern oder den $-Operator:, um einen Vektor zu bekommen:\n\n\npinguine[[\"species\"]]\n\n[1] Adelie Adelie Adelie Adelie Adelie\nLevels: Adelie Chinstrap Gentoo\n\n\n\npinguine$species\n\n[1] Adelie Adelie Adelie Adelie Adelie\nLevels: Adelie Chinstrap Gentoo\n\n\n\nNutze einfache Klammern, um ein Tibble mit einer Spalte zu bekommen:\n\n\npinguine[\"species\"]\n\n# A tibble: 5 Ã— 1\n  species\n  &lt;fct&gt;  \n1 Adelie \n2 Adelie \n3 Adelie \n4 Adelie \n5 Adelie \n\n\n\n\nMehrere Spalten\n\npinguine[c(\"species\", \"island\")]\n\n# A tibble: 5 Ã— 2\n  species island   \n  &lt;fct&gt;   &lt;fct&gt;    \n1 Adelie  Torgersen\n2 Adelie  Torgersen\n3 Adelie  Torgersen\n4 Adelie  Torgersen\n5 Adelie  Torgersen"
  },
  {
    "objectID": "5_DataStructures/9.5_dfColumnsNames.html#matrix-style",
    "href": "5_DataStructures/9.5_dfColumnsNames.html#matrix-style",
    "title": "Spalten - Namen in Data Frame",
    "section": "Matrix Style",
    "text": "Matrix Style\n\nEinzelne Spalte\n\npinguine[, \"species\"]\n\n# A tibble: 5 Ã— 1\n  species\n  &lt;fct&gt;  \n1 Adelie \n2 Adelie \n3 Adelie \n4 Adelie \n5 Adelie \n\n\n\n\nMehrere Spalten\n\npinguine[, c(\"species\", \"island\")]\n\n# A tibble: 5 Ã— 2\n  species island   \n  &lt;fct&gt;   &lt;fct&gt;    \n1 Adelie  Torgersen\n2 Adelie  Torgersen\n3 Adelie  Torgersen\n4 Adelie  Torgersen\n5 Adelie  Torgersen"
  },
  {
    "objectID": "5_DataStructures/9.7_dfCombine.html",
    "href": "5_DataStructures/9.7_dfCombine.html",
    "title": "Zwei Data Frames kombinieren",
    "section": "",
    "text": "Der Inhalt von zwei Data Frames soll zu einem Data Frame zusammengefÃ¼gt werden.\nWir nutzen den penguins-Datensatz aus dem palmerpenguins Paket:\n\n\nlibrary(dplyr)\nlibrary(palmerpenguins)\ndata(\"penguins\")\n\n\n\n\nHier erstellen wir zwei DatensÃ¤tze durch Auswahl von Spaltenindizes:\n\n\npinguSpalten1 &lt;- penguins |&gt;\n  select(1:4)\nhead(pinguSpalten1)\n\n# A tibble: 6 Ã— 4\n  species island    bill_length_mm bill_depth_mm\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;\n1 Adelie  Torgersen           39.1          18.7\n2 Adelie  Torgersen           39.5          17.4\n3 Adelie  Torgersen           40.3          18  \n4 Adelie  Torgersen           NA            NA  \n5 Adelie  Torgersen           36.7          19.3\n6 Adelie  Torgersen           39.3          20.6\n\npinguSpalten2 &lt;- penguins |&gt;\n  select(5:8)\nhead(pinguSpalten2)\n\n# A tibble: 6 Ã— 4\n  flipper_length_mm body_mass_g sex     year\n              &lt;int&gt;       &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n1               181        3750 male    2007\n2               186        3800 female  2007\n3               195        3250 female  2007\n4                NA          NA &lt;NA&gt;    2007\n5               193        3450 female  2007\n6               190        3650 male    2007\n\n\n\nUm die Spalten wieder zusammenzufÃ¼hren, kÃ¶nnen wir die Funktion cbind() aus dem dplyr Paket verwenden:\n\n\nalleSpalten.pinguine &lt;- cbind(pinguSpalten1, pinguSpalten2)\nhead(alleSpalten.pinguine)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\n\n\n\n\nWir erstellen zwei DatensÃ¤tze, indem wir List expressions verwenden:\n\n\npinguReihen1 &lt;- penguins[c(1:4), ]\npinguReihen1\n\n# A tibble: 4 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\npinguReihen2 &lt;- penguins[c(5:8), ]\npinguReihen2\n\n# A tibble: 4 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           36.7          19.3               193        3450\n2 Adelie  Torgersen           39.3          20.6               190        3650\n3 Adelie  Torgersen           38.9          17.8               181        3625\n4 Adelie  Torgersen           39.2          19.6               195        4675\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\nUm die Reihen zusammenzufÃ¼hren, nutzen wir rbind() aus dem dplyr Paket:\n\n\nalleReihen.pinguine &lt;- rbind(pinguReihen1, pinguReihen2)\nalleReihen.pinguine\n\n# A tibble: 8 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n7 Adelie  Torgersen           38.9          17.8               181        3625\n8 Adelie  Torgersen           39.2          19.6               195        4675\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;"
  },
  {
    "objectID": "5_DataStructures/9.7_dfCombine.html#spalten-und-reihen-zusammenfÃ¼hren",
    "href": "5_DataStructures/9.7_dfCombine.html#spalten-und-reihen-zusammenfÃ¼hren",
    "title": "Zwei Data Frames kombinieren",
    "section": "",
    "text": "Der Inhalt von zwei Data Frames soll zu einem Data Frame zusammengefÃ¼gt werden.\nWir nutzen den penguins-Datensatz aus dem palmerpenguins Paket:\n\n\nlibrary(dplyr)\nlibrary(palmerpenguins)\ndata(\"penguins\")\n\n\n\n\nHier erstellen wir zwei DatensÃ¤tze durch Auswahl von Spaltenindizes:\n\n\npinguSpalten1 &lt;- penguins |&gt;\n  select(1:4)\nhead(pinguSpalten1)\n\n# A tibble: 6 Ã— 4\n  species island    bill_length_mm bill_depth_mm\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;\n1 Adelie  Torgersen           39.1          18.7\n2 Adelie  Torgersen           39.5          17.4\n3 Adelie  Torgersen           40.3          18  \n4 Adelie  Torgersen           NA            NA  \n5 Adelie  Torgersen           36.7          19.3\n6 Adelie  Torgersen           39.3          20.6\n\npinguSpalten2 &lt;- penguins |&gt;\n  select(5:8)\nhead(pinguSpalten2)\n\n# A tibble: 6 Ã— 4\n  flipper_length_mm body_mass_g sex     year\n              &lt;int&gt;       &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n1               181        3750 male    2007\n2               186        3800 female  2007\n3               195        3250 female  2007\n4                NA          NA &lt;NA&gt;    2007\n5               193        3450 female  2007\n6               190        3650 male    2007\n\n\n\nUm die Spalten wieder zusammenzufÃ¼hren, kÃ¶nnen wir die Funktion cbind() aus dem dplyr Paket verwenden:\n\n\nalleSpalten.pinguine &lt;- cbind(pinguSpalten1, pinguSpalten2)\nhead(alleSpalten.pinguine)\n\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   &lt;NA&gt; 2007\n5 female 2007\n6   male 2007\n\n\n\n\n\n\nWir erstellen zwei DatensÃ¤tze, indem wir List expressions verwenden:\n\n\npinguReihen1 &lt;- penguins[c(1:4), ]\npinguReihen1\n\n# A tibble: 4 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\npinguReihen2 &lt;- penguins[c(5:8), ]\npinguReihen2\n\n# A tibble: 4 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           36.7          19.3               193        3450\n2 Adelie  Torgersen           39.3          20.6               190        3650\n3 Adelie  Torgersen           38.9          17.8               181        3625\n4 Adelie  Torgersen           39.2          19.6               195        4675\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;\n\n\n\nUm die Reihen zusammenzufÃ¼hren, nutzen wir rbind() aus dem dplyr Paket:\n\n\nalleReihen.pinguine &lt;- rbind(pinguReihen1, pinguReihen2)\nalleReihen.pinguine\n\n# A tibble: 8 Ã— 8\n  species island    bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n  &lt;fct&gt;   &lt;fct&gt;              &lt;dbl&gt;         &lt;dbl&gt;             &lt;int&gt;       &lt;int&gt;\n1 Adelie  Torgersen           39.1          18.7               181        3750\n2 Adelie  Torgersen           39.5          17.4               186        3800\n3 Adelie  Torgersen           40.3          18                 195        3250\n4 Adelie  Torgersen           NA            NA                  NA          NA\n5 Adelie  Torgersen           36.7          19.3               193        3450\n6 Adelie  Torgersen           39.3          20.6               190        3650\n7 Adelie  Torgersen           38.9          17.8               181        3625\n8 Adelie  Torgersen           39.2          19.6               195        4675\n# â„¹ 2 more variables: sex &lt;fct&gt;, year &lt;int&gt;"
  },
  {
    "objectID": "5_DataStructures/9.7_dfCombine.html#data-frames-anhand-einer-gemeinsamen-spalte-zusammenfÃ¼gen",
    "href": "5_DataStructures/9.7_dfCombine.html#data-frames-anhand-einer-gemeinsamen-spalte-zusammenfÃ¼gen",
    "title": "Zwei Data Frames kombinieren",
    "section": "Data Frames anhand einer gemeinsamen Spalte zusammenfÃ¼gen",
    "text": "Data Frames anhand einer gemeinsamen Spalte zusammenfÃ¼gen\n\nWir haben zwei DatensÃ¤tze, die eine gemeinsamt Spalte haben\nDie gemeinsame Spalte ist oft ein Index oder individueller Pseudonimisierungscode, der fÃ¼r jede Beobachtung / Zeile einzigartig ist\nBei unserem Pinguin-Datensatz gibt es eine solche Spalte nicht, deshalb erstellen wir eine:\n\n\npinguine &lt;- penguins |&gt;\n  head(8)\npinguIndex &lt;- c(1:8)\n\npinguine &lt;- cbind(pinguIndex, pinguine)\n\n\nFÃ¼r deskriptive Auswertungen haben wir Geschlecht und Jahr aus dem Datensatz einzeln angeschaut und fehlende Werte ausgeschlossen:\n\n\npinguGeschlecht &lt;- pinguine |&gt;\n  select(\"pinguIndex\", \"sex\") |&gt;\n  na.omit()\npinguGeschlecht\n\n  pinguIndex    sex\n1          1   male\n2          2 female\n3          3 female\n5          5 female\n6          6   male\n7          7 female\n8          8   male\n\npinguJahr &lt;- pinguine |&gt;\n  select(\"pinguIndex\", \"year\")\npinguJahr\n\n  pinguIndex year\n1          1 2007\n2          2 2007\n3          3 2007\n4          4 2007\n5          5 2007\n6          6 2007\n7          7 2007\n8          8 2007\n\n\n\nZusammenfÃ¼hren\n\nUm die Daten wieder zusammenzufÃ¼hren, nutzen wir join() - Funktionen aus dem Paket dplyr.\ninner_join() erhÃ¤lt nur die Daten, die in beiden DatensÃ¤tzen vorkommen.\nfull_join() erhÃ¤lt alle Daten\nleft_join() erhÃ¤lt alle Daten aus dem ersten Datensatz\nright_join() erhÃ¤lt alle Daten aus dem zweiten Datensatz\n\n\npingu_inner &lt;- inner_join(pinguGeschlecht, pinguJahr)\n\nJoining with `by = join_by(pinguIndex)`\n\npingu_inner\n\n  pinguIndex    sex year\n1          1   male 2007\n2          2 female 2007\n3          3 female 2007\n4          5 female 2007\n5          6   male 2007\n6          7 female 2007\n7          8   male 2007\n\n\n\nDurch inner_join() ist ein Wert in year ausgeschlossen worden, der zuvor aufgrund von NA in der Variable sex aus dem ersten Datensatz gelÃ¶scht worden war.\nMit full_join() oder right_join() hÃ¤tte man in dem Fall alle Daten erhalten.\n\n\n Wichtig!\nÃœberlege beim Anwenden von join()-Methoden immer genau, was du damit bezweckst und welche Daten du nicht verlieren mÃ¶chtest. So kannst du bÃ¶se Ãœberraschungen vermeiden."
  }
]